1. Create Azure AD B2C App registrations for two Apps
    - API Portal
    - API Gateway

    Attributes to be captured:
      - client-id
      - client-secret
      - issuer-uri
      - redirect-url

2. Provision an AKS Cluster
    $ az aks create -g ajscg -n scg-portal --network-plugin azure --network-policy calico -c 3 -s Standard_A8_v2 --generate-ssh-keys --no-wait
    $ az aks get-credentials -g ajscg -n scg-portal

3. Install Contour as an Ingress Controller
    $ kubectl apply -f https://projectcontour.io/quickstart/contour.yaml
    $ kubectl get all -n projectcontour

4. Map external DNS of the envoy (projectcontour ns) LB to a wild card domain
    Map *.jci.onepivotal.net to 20.80.64.167

4. Install Cert-Manager
    $ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.yaml

5. Install Let's Encrypt pointing to the staging server

    apiVersion: cert-manager.io/v1
    kind: ClusterIssuer
    metadata:
      name: letsencrypt-staging
      namespace: cert-manager
    spec:
      acme:
        email: akadari@vmware.com
        privateKeySecretRef:
          name: letsencrypt-staging
        server: https://acme-staging-v02.api.letsencrypt.org/directory
        solvers:
        - http01:
            ingress:
              class: contour

6. Validate Let's Encrypt Staging ClusterIssuer is installed
    $ kubectl get clusterissuer -A

7. Install Hashicorp Vault in DEV using dev-vault-values.yaml
    $ helm install vault hashicorp/vault -n vault --version 0.24.1 -f dev-vault-values.yaml

8. Validate Hashicorp is installed
    $ kubectl get all -n vault

9. Configure Vault for API Key Management
    a. Login to vault server pod
      $ kubectl -n vault exec -it vault-0 -- /bin/sh

    b. Enable Key-Value store, api-portal-keys, of type kv-v2
      $ vault secrets enable -path=api-portal-keys kv-v2

      >> Success! Enabled the kv-v2 secrets engine at: api-portal-keys/

    c. Create an access policy in Vault for API-Portal to perform all operations.

(
cat << EOF
  path "api-portal-keys/data/*" {
    capabilities = ["create", "read", "update", "delete", "list"]
  }
  path "api-portal-keys/metadata/*" {
    capabilities = ["list", "delete"]
  }
EOF
) | vault policy write api-portal-policy -


>> Success! Uploaded policy: api-portal-policy


    d. Create an access policy in Vault for Spring Cloud Gateway to read the API-Keys.

(
cat << EOF
  path "api-portal-keys/data/my-group-id*" {
    capabilities = ["read"]
  }
  path "api-portal-keys/metadata/my-group-id*" {
    capabilities = ["list"]
  }
EOF
) | vault policy write gateway-policy -


>> Success! Uploaded policy: gateway-policy


    e. Connecting Vault to the Kubernetes cluster.

            $ vault auth enable kubernetes

            >> Success! Enabled kubernetes auth method at: kubernetes/

    f. As the Vault instance is on the same cluster as the API-Portal and API-Gateway,
            the following configuration helps Kubernetes deployments access Vault.

$ vault write auth/kubernetes/config \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

    >> Success! Data written to: auth/kubernetes/config



    g. Create roles to bind the namespaced ServiceAccount to the role (Access Policy) created earlier.

            $ vault write auth/kubernetes/role/api-portal-role \
                bound_service_account_names=api-portal-sa \
                bound_service_account_namespaces=api-portal \
                policies=api-portal-policy \
                ttl=24h

            >> Success! Data written to: auth/kubernetes/role/api-portal-role

            $ vault write auth/kubernetes/role/gateway-role \
                bound_service_account_names=gateway-sa \
                bound_service_account_namespaces=spring-cloud-gateway \
                policies=gateway-policy \
                ttl=24h

            >> Success! Data written to: auth/kubernetes/role/gateway-role

10. Complete single-sign-on steps to configure SSO for API-Portal.

      a. Create a file called api-portal-sso-credentials.txt,
         including the following properties from the AD B2C values captured above.

          scope=openid,profile,email
          client-id={your_client_id}
          client-secret={your_client_secret}
          issuer-uri={your_issuer_uri}
          user-name-attribute={optional_user_name_attribute_key}

      b. Create the API portal installation namespace if it doesn't already exist

          $ kubectl create ns api-portal

      c. In the API portal installation namespace (api-portal), create a Kubernetes secret named
         sso-credentials using the api-portal-sso-credentials.txt file created in the previous step.

          $ kubectl create secret generic sso-credentials --from-env-file=./api-portal-sso-credentials.txt -n api-portal

          >> secret/sso-credentials created

      d. Validate that the sso-credentials secret is created in the api-portal namespace.

          $ kubectl get secret -n api-portal

11. Relocate images to a container registry.

          $ ./scripts/relocate-images.sh ${REGISTRY_URL}/api-portal

12.  Create a values file, api-portal-values.yaml to be used for API-Portal deployment using the package that I will provide.

apiPortalServer:
  image: "ajtanzuregistry.azurecr.io/api-portal/api-portal-server:1.3.6" <replace as needed>
  sourceUrls: "http://animal-rescue.jci.onepivotal.net/openapi" <replace as needed>
  title: "Johnson Controls Application Portal" <replace as needed>
  description: "Developer Portal for discvoering APIs" <replace as needed>
  imagePullPolicy: IfNotPresent
  registryCredentialsSecret: api-portal-image-pull-secret
  replicaCount: 1
  sourceUrlsCacheTtlSec: "300"
  sourceUrlsTimeoutSec: "10"
  requestMemory: "512Mi"
  requestCpu: "100m"
  limitMemory: "1024Mi"
  limitCpu: "500m"
  namespace: "api-portal"
  trustInsecureSourceUrls: true
  caCertData: ""

sso:
  enabled: true
  secretName: sso-credentials

apiKey:
  enabled: true
  vault:
    url: "http://vault.vault.svc:8200/"
    role: api-portal-role
    path: api-portal-keys

serviceAccount:
  create: true
  name: api-portal-sa


13. Deploy API-Portal

    $ ./scripts/install-api-portal.sh --namespace api-portal --values ./helm/api-portal-image-values.yaml

    >>  chart tarball: api-portal-1.3.6.tgz
        chart name: api-portal
        Waiting up to 5m for helm installation to complete
        Release "api-portal" does not exist. Installing it now.
        NAME: api-portal
        LAST DEPLOYED: Mon Jun  5 22:16:07 2023
        NAMESPACE: api-portal
        STATUS: deployed
        REVISION: 1
        TEST SUITE: None
        NOTES:
        * API Key is enabled
        * SSO is enabled
        Successfully installed Api portal

14. Validate that role (api-portal-role) is created, if not create one with the below yaml.

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: api-portal-role
  namespace: api-portal
rules:
- apiGroups:
  - ""
  resources:
  - services
  - endpoints
  verbs:
  - create
  - read
  - update
  - delete
  - list
- apiGroups:
  - discovery.k8s.io
  resources:
  - endpointslices
  verbs:
  - list
  - delete

      $ kubectl apply -f api-portal-role.yaml

15. Validate that the rolebinding (api-portal-role-binding) is created, if not create one with the below command.

      $ k create rolebinding api-portal-role-binding --role=api-portal-role --serviceaccount=api-portal:api-portal-sa -n api-portal

16. Configure Ingress for the API-Portal with the below content in api-portal-ingress-config.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-portal
  namespace: api-portal
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-staging
    ingress.kubernetes.io/force-ssl-redirect: "true"
    kubernetes.io/ingress.class: contour
    kubernetes.io/tls-acme: "true"
spec:
  tls:
  - secretName: api-portal-cert
    hosts:
    - api-portal.jci.onepivotal.net
  rules:
  - host: api-portal.jci.onepivotal.net
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: api-portal-server
            port:
              number: 8080

        $ kubectl apply -f api-portal-ingress-config.yaml

17. Relocate Spring Cloud Gateway Images.

        $ ./scripts/relocate-images.sh ${registry_url}/spring-cloud-gateway

    >> The relocation creates helm/scg-image-values.yaml file

18. Install the Spring Cloud Gateway operator

        $ ./scripts/install-spring-cloud-gateway.sh

        >>  chart tarball: spring-cloud-gateway-2.1.0-alpha.1.tgz
            chart name: spring-cloud-gateway
            Waiting up to 2m for helm installation to complete
            Release "spring-cloud-gateway" does not exist. Installing it now.
            NAME: spring-cloud-gateway
            LAST DEPLOYED: Mon Jun  5 22:52:59 2023
            NAMESPACE: spring-cloud-gateway
            STATUS: deployed
            REVISION: 1
            TEST SUITE: None
            NOTES:
            This chart contains the Kubernetes operator for Spring Cloud Gateway.
            Install the chart spring-cloud-gateway-crds before installing this chart

            Checking Operator pod state
            deployment "scg-operator" successfully rolled out
            ✔ Operator pods are running

            Checking custom resource definitions
            ✓ springcloudgatewaymappings.tanzu.vmware.com successfully installed
            ✓ springcloudgatewayrouteconfigs.tanzu.vmware.com successfully installed
            ✓ springcloudgateways.tanzu.vmware.com successfully installed

            Successfully installed Spring Cloud Gateway operator

19. Validate that the ClusterRole (scg-operator-resources-role) is created. This ClusterRole is used
    for creating SpringCloudGateway instances in arbitrary namespaces in the Cluster.

    $ kubectl describe ClusterRole scg-operator-resources-role

20.

